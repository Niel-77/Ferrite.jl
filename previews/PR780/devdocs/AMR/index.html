<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adaptive Mesh Refinement (AMR) · Ferrite.jl</title><meta name="title" content="Adaptive Mesh Refinement (AMR) · Ferrite.jl"/><meta property="og:title" content="Adaptive Mesh Refinement (AMR) · Ferrite.jl"/><meta property="twitter:title" content="Adaptive Mesh Refinement (AMR) · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/devdocs/AMR/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/devdocs/AMR/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/devdocs/AMR/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Tutorials overview</a></li><li><a class="tocitem" href="../../tutorials/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../tutorials/linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../../tutorials/incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../../tutorials/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../tutorials/plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../../tutorials/transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../../tutorials/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../tutorials/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../tutorials/porous_media/">Porous media</a></li><li><a class="tocitem" href="../../tutorials/ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../tutorials/dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Topic guide overview</a></li><li><a class="tocitem" href="../../topics/fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../../topics/FEValues/">FEValues</a></li><li><a class="tocitem" href="../../topics/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../topics/assembly/">Assembly</a></li><li><a class="tocitem" href="../../topics/boundary_conditions/">Initial and Boundary Conditions</a></li><li><a class="tocitem" href="../../topics/constraints/">Constraints</a></li><li><a class="tocitem" href="../../topics/grid/">Grid</a></li><li><a class="tocitem" href="../../topics/export/">Export</a></li><li><a class="tocitem" href="../../topics/amr/">Adaptive Mesh Refinement</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../">Developer documentation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Adaptive Mesh Refinement (AMR)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adaptive Mesh Refinement (AMR)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/devdocs/AMR.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Adaptive-Mesh-Refinement-(AMR)"><a class="docs-heading-anchor" href="#Adaptive-Mesh-Refinement-(AMR)">Adaptive Mesh Refinement (AMR)</a><a id="Adaptive-Mesh-Refinement-(AMR)-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Mesh-Refinement-(AMR)" title="Permalink"></a></h1><h2 id="P4est"><a class="docs-heading-anchor" href="#P4est">P4est</a><a id="P4est-1"></a><a class="docs-heading-anchor-permalink" href="#P4est" title="Permalink"></a></h2><p>Ferrite&#39;s P4est implementation is based on these papers:</p><ul><li><a href="../../references/#BWG2011">Burstedde *et al.* [11]</a></li><li><a href="../../references/#IBWG2015">Isaac *et al.* [12]</a></li></ul><p>where almost everything is implemented in a serial way from the first paper. Only certain specific algorithms of the second paper are implemented and there is a lot of open work to include the iterators of the second paper. Look into the issues of Ferrite.jl and search for the AMR tag.</p><h3 id="Important-Concepts"><a class="docs-heading-anchor" href="#Important-Concepts">Important Concepts</a><a id="Important-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Important-Concepts" title="Permalink"></a></h3><p>One of the most important concepts, which everything is based on, are space filling curves (SFC). In particular, <a href="https://en.wikipedia.org/wiki/Z-order_curve">Z-order (also named Morton order, Morton space-filling curves)</a> are used in p4est. The basic idea is that each Octant (in 3D) or quadrant (in 2D) can be encoded by 2 quantities</p><ul><li>the level <code>l</code></li><li>the lower left (front) coordinates <code>xyz</code></li></ul><p>Based on them a unique identifier, the morton index, can be computed. The mapping from (<code>l</code>, <code>xyz</code>) -&gt; <code>mortonidx(l,xyz)</code> is bijective, meaning we can flip the approach and can construct each octant/quadrant solely by the <code>mortonidx</code> and a given level <code>l</code>.</p><p>The current implementation of an octant looks currently like this:</p><pre><code class="language-julia hljs">struct OctantBWG{dim, N, T} &lt;: AbstractCell{RefHypercube{dim}}
    #Refinement level
    l::T
    #x,y,z \in {0,...,2^b} where (0 ≤ l ≤ b)}
    xyz::NTuple{dim,T}
end</code></pre><p>whenever coordinates are considered we follow the z order logic, meaning x before y before z. Note that the acronym BWG stands for the initials of the surname of the authors of the p4est paper. The coordinates of an octant are described in the <em>octree coordinate system</em> which goes from <span>$[0,2^b]^{dim}$</span>. The parameter <span>$b$</span> describes the maximum level of refinement and is set a priori. Another important aspect of the octree coordinate system is, that it is a discrete integer coordinate system. The size of an octant at the lowest possible level <code>b</code> is always 1, sometimes these octants are called atoms.</p><p>The octree is implemented as:</p><pre><code class="language-julia hljs">struct OctreeBWG{dim,N,T} &lt;: AbstractAdaptiveCell{RefHypercube{dim}}
    leaves::Vector{OctantBWG{dim,N,T}}
    #maximum refinement level
    b::T
    nodes::NTuple{N,Int}
end</code></pre><p>So, only the leaves of the tree are stored and not any intermediate refinement level. The field <code>b</code> is the maximum refinement level and is crucial. This parameter determines the size of the octree coordinate system. The octree coordinate system is the coordinate system in which the coordinates <code>xyz</code> of any <code>octant::OctantBWG</code> are described.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>Let&#39;s say the maximum octree level is <span>$b=3$</span>, then the coordinate system is in 2D <span>$[0,2^3]^2 = [0, 8]^2$</span>. So, our root is on level 0 of size 8 and has the lower left coordinates <code>(0,0)</code></p><pre><code class="language-julia hljs"># different constructors available, first one OctantBWG(dim,level,mortonid,maximumlevel)
# other possibility by giving directly level and a tuple of coordinates OctantBWG(level,(x,y))
julia&gt; dim = 2; level = 0; maximumlevel=3
julia&gt; oct = OctantBWG(dim,level,1,maximumlevel)
OctantBWG{2,4,4}
   l = 0
   xy = 0,0</code></pre><p>The size of octants at a specific level can be computed by a simple operation</p><pre><code class="language-julia hljs">julia&gt; Ferrite.AMR._compute_size(#=b=#3,#=l=#0)
8</code></pre><p>This computation is based on the relation <span>$\text{size}=2^{b-l}$</span>. Now, to fully understand the octree coordinate system we go a level down, i.e. we cut the space in <span>$x$</span> and <span>$y$</span> in half. This means, that the octants are now of size <span>$2^{3-1}=4$</span>. Construct all level 1 octants based on mortonid:</p><pre><code class="language-julia hljs"># note the arguments are dim,level,mortonid,maximumlevel
julia&gt; dim = 2; level = 1; maximumlevel = 3
julia&gt; oct = Ferrite.AMR.OctantBWG(dim, level, 1, maximumlevel)
OctantBWG{2,4,4}
   l = 1
   xy = 0,0

julia&gt; oct = Ferrite.AMR.OctantBWG(dim, level, 2, maximumlevel)
OctantBWG{2,4,4}
   l = 1
   xy = 4,0

julia&gt; oct = Ferrite.AMR.OctantBWG(dim, level, 3, maximumlevel)
OctantBWG{2,4,4}
   l = 1
   xy = 0,4

julia&gt; oct = Ferrite.AMR.OctantBWG(dim, level, 4, maximumlevel)
OctantBWG{2,4,4}
   l = 1
   xy = 4,4</code></pre><p>So, the morton index is on <strong>one</strong> specific level just a x before y before z &quot;cell&quot; or &quot;element&quot; identifier</p><pre><code class="nohighlight hljs">x-----------x-----------x
|           |           |
|           |           |
|     3     |     4     |
|           |           |
|           |           |
x-----------x-----------x
|           |           |
|           |           |
|     1     |     2     |
|           |           |
|           |           |
x-----------x-----------x</code></pre><p>The operation to compute octants/quadrants is cheap, since it is just bitshifting. An important aspect of the morton index is that it&#39;s only consecutive on <strong>one</strong> level in this specific implementation. Note that other implementation exists that incorporate the level integer within the morton identifier and by that have a unique identifier across levels. If you have a tree like this below:</p><pre><code class="nohighlight hljs">x-----------x-----------x
|           |           |
|           |           |
|     9     |    10     |
|           |           |
|           |           |
x-----x--x--x-----------x
|     |6 |7 |           |
|  3  x--x--x           |
|     |4 |5 |           |
x-----x--x--x     8     |
|     |     |           |
|  1  |  2  |           |
x-----x-----x-----------x</code></pre><p>you would maybe think this is the morton index, but strictly speaking it is not. What we see above is just the <code>leafindex</code>, i.e. the index where you find this leaf in the <code>leaves</code> array of <code>OctreeBWG</code>. Let&#39;s try to construct the lower right based on the morton index on level 1</p><pre><code class="language-julia hljs">julia&gt; o = Ferrite.OctantBWG(2,1,8,3)
ERROR: AssertionError: m ≤ (one(T) + one(T)) ^ (dim * l) # 8 &gt; 4
Stacktrace:
 [1] OctantBWG(dim::Int64, l::Int32, m::Int32, b::Int32)
   @ Ferrite ~/repos/Ferrite.jl/src/Adaptivity/AdaptiveCells.jl:23
 [2] OctantBWG(dim::Int64, l::Int64, m::Int64, b::Int64)
   @ Ferrite ~/repos/Ferrite.jl/src/Adaptivity/AdaptiveCells.jl:43
 [3] top-level scope
   @ REPL[93]:1</code></pre><p>The assertion expresses that it is not possible to construct a morton index 8 octant, since the upper bound of the morton index is 4 on level 1. The morton index of the lower right cell is 2 on level 1.</p><pre><code class="language-julia hljs">julia&gt; o = Ferrite.AMR.OctantBWG(2,1,2,3)
OctantBWG{2,4,4}
   l = 1
   xy = 4,0</code></pre><h3 id="Octant-operation"><a class="docs-heading-anchor" href="#Octant-operation">Octant operation</a><a id="Octant-operation-1"></a><a class="docs-heading-anchor-permalink" href="#Octant-operation" title="Permalink"></a></h3><p>There are multiple useful functions to compute information about an octant e.g. parent, childs, etc.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.isancestor" href="#Ferrite.AMR.isancestor"><code>Ferrite.AMR.isancestor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isancestor(o1,o2,b) -&gt; Bool</code></pre><p>Is o2 an ancestor of o1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1179-L1182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.morton" href="#Ferrite.AMR.morton"><code>Ferrite.AMR.morton</code></a> — <span class="docstring-category">Function</span></header><section><div><p>From <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a>;</p><blockquote><p>The octant coordinates are stored as integers of a fixed number b of bits, where the highest (leftmost) bit represents the first vertical level of the octree (counting the root as level zero), the second highest bit the second level of the octree, and so on.</p></blockquote><p>A morton index can thus be constructed by interleaving the integer bits (2D): <span>$m(\text{Oct}) := (y_b,x_b,y_{b-1},x_{b-1},...y_0,x_0)_2$</span> further we assume the following</p><blockquote><p>Due to the two-complement representation of integers in practically all current hardware, where the highest digit denotes the negated appropriate power of two, bitwise operations as used, for example, in Algorithm 1 yield the correct result even for negative coordinates.</p></blockquote><p>also from <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a></p><p>TODO: use LUT method from https://www.forceflow.be/2013/10/07/morton-encodingdecoding-through-bit-interleaving-implementations/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L61-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.children" href="#Ferrite.AMR.children"><code>Ferrite.AMR.children</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">children(octant::OctantBWG{dim,N,T}, b::Integer) -&gt; NTuple{M,OctantBWG}</code></pre><p>Computes all childern of <code>octant</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L120-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.vertices" href="#Ferrite.AMR.vertices"><code>Ferrite.AMR.vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vertices(octant::OctantBWG{dim}, b::Integer)</code></pre><p>Computes all vertices of a given <code>octant</code>. Each vertex is encoded within the octree coordinates i.e. by integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.edges" href="#Ferrite.AMR.edges"><code>Ferrite.AMR.edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edges(octant::OctantBWG{dim}, b::Integer)</code></pre><p>Computes all edges of a given <code>octant</code>. Each edge is encoded within the octree coordinates i.e. by integers. Further, each edge consists of two three-dimensional integer coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.faces" href="#Ferrite.AMR.faces"><code>Ferrite.AMR.faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">faces(octant::OctantBWG{dim}, b::Integer)</code></pre><p>Computes all faces of a given <code>octant</code>. Each face is encoded within the octree coordinates i.e. by integers. Further, each face consists of either two two-dimensional integer coordinates or four three-dimensional integer coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_pointBWG" href="#Ferrite.AMR.transform_pointBWG"><code>Ferrite.AMR.transform_pointBWG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_pointBWG(forest, vertices) -&gt; Vector{Vec{dim}}
transform_pointBWG(forest::ForestBWG{dim}, k::Integer, vertex::NTuple{dim,T}) where {dim,T} -&gt; Vec{dim}</code></pre><p>Transformation of a octree coordinate system point <code>vertex</code> (or a collection <code>vertices</code>) to the corresponding physical coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L552-L557">source</a></section></article><h3 id="Intraoctree-operation"><a class="docs-heading-anchor" href="#Intraoctree-operation">Intraoctree operation</a><a id="Intraoctree-operation-1"></a><a class="docs-heading-anchor-permalink" href="#Intraoctree-operation" title="Permalink"></a></h3><p>Intraoctree operation stay within one octree and compute octants that are attached in some way to a pivot octant <code>o</code>. These operations are useful to collect unique entities within a single octree or to compute possible neighbors of <code>o</code>. <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a> Algorithm 5, 6, and 7 describe the following intraoctree operations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.corner_neighbor" href="#Ferrite.AMR.corner_neighbor"><code>Ferrite.AMR.corner_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">corner_neighbor(octant::OctantBWG, c::Integer, b::Integer)</code></pre><p>Computes the corner neighbor octant which is only connected by the corner <code>c</code> to <code>octant</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1745-L1748">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.edge_neighbor" href="#Ferrite.AMR.edge_neighbor"><code>Ferrite.AMR.edge_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_neighbor(octant::OctantBWG, e::Integer, b::Integer)</code></pre><p>Computes the edge neighbor octant which is only connected by the edge <code>e</code> to <code>octant</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1722-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.face_neighbor" href="#Ferrite.AMR.face_neighbor"><code>Ferrite.AMR.face_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">face_neighbor(octant::OctantBWG{dim,N,T}, f::T, b::T=_maxlevel[2]) -&gt; OctantBWG{3,N,T}</code></pre><p>Intraoctree face neighbor for a given faceindex <code>f</code> (in p4est, i.e. z order convention) and specified maximum refinement level <code>b</code>. Implements Algorithm 5 of <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a>.</p><pre><code class="nohighlight hljs">x-------x-------x
|       |       |
|   3   |   4   |
|       |       |
x-------x-------x
|       |       |
o   1   *   2   |
|       |       |
x-------x-------x</code></pre><p>Consider octant 1 at <code>xyz=(0,0)</code>, a maximum refinement level of 1 and faceindex 2 (marked as <code>*</code>). Then, the computed face neighbor will be octant 2 with <code>xyz=(1,0)</code>. Note that the function is not sensitive in terms of leaving the octree boundaries. For the above example, a query for face index 1 (marked as <code>o</code>) will return an octant outside of the octree with <code>xyz=(-1,0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1320-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.possibleneighbors" href="#Ferrite.AMR.possibleneighbors"><code>Ferrite.AMR.possibleneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">possibleneighbors(o::OctantBWG{2},l,b;insidetree=true)</code></pre><p>Returns a list of possible neighbors, where the first four are corner neighbors that are exclusively connected via a corner. The other four possible neighbors are face neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1136-L1140">source</a></section><section><div><pre><code class="language-julia hljs">possibleneighbors(o::OctantBWG{3},l,b;insidetree=true)</code></pre><p>Returns a list of possible neighbors, where the first eight are corner neighbors that are exclusively connected via a corner. After the first eight corner neighbors, the 6 possible face neighbors follow and after them, the edge neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1156-L1160">source</a></section></article><h3 id="Interoctree-operation"><a class="docs-heading-anchor" href="#Interoctree-operation">Interoctree operation</a><a id="Interoctree-operation-1"></a><a class="docs-heading-anchor-permalink" href="#Interoctree-operation" title="Permalink"></a></h3><p>Interoctree operation are in contrast to intraoctree operation by computing octant transformations across different octrees. Thereby, one needs to account for topological connections between the octrees as well as possible rotations of the octrees. <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a> Algorithm 8, 10, and 12 explain the algorithms that are implemented in the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_corner" href="#Ferrite.AMR.transform_corner"><code>Ferrite.AMR.transform_corner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_corner(forest,k,c&#39;,oct,inside::Bool)
transform_corner(forest,v::VertexIndex,oct,inside::Bool)</code></pre><p>Algorithm 12 but with flipped logic in <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a> to transform corner into different octree coordinate system Implements flipped logic in the sense of pushing the Octant <code>oct</code> through vertex v and stays within octree coordinate system <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1600-L1606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_edge" href="#Ferrite.AMR.transform_edge"><code>Ferrite.AMR.transform_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_edge(forest,k,e,oct,inside::Bool)
transform_edge(forest,e::Edgeindex,oct,inside::Bool)</code></pre><p>Algorithm 10 in <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a> to transform cedge into different octree coordinate system but reversed logic. See <code>transform_edge_remote</code> with logic from paper. In this function we stick to the coordinate system of the pivot tree k and transform an octant through edge e into this k-th octree coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1683-L1690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_face" href="#Ferrite.AMR.transform_face"><code>Ferrite.AMR.transform_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_face(forest::ForestBWG, k&#39;, f&#39;, o::OctantBWG) -&gt; OctantBWG
transform_face(forest::ForestBWG, f&#39;::FaceIndex, o::OctantBWG) -&gt; OctantBWG</code></pre><p>Interoctree coordinate transformation of an given octant <code>o</code> that lies outside of the pivot octree <code>k</code>, namely in neighbor octree <code>k&#39;</code>. However, the coordinate of <code>o</code> is given in octree coordinates of <code>k</code>. Thus, this algorithm implements the transformation of the octree coordinates of <code>o</code> into the octree coordinates of <code>k&#39;</code>. Useful in order to check whether or not a possible neighbor exists in a neighboring octree. Implements Algorithm 8 of <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a>.</p><pre><code class="nohighlight hljs">x-------x-------x
|       |       |
|   3   |   4   |
|       |       |
x-------x-------x
|       |       |
|   1   *   2   |
|       |       |
x-------x-------x</code></pre><p>Consider 4 octrees with a single leaf each and a maximum refinement level of 1 This function transforms octant 1 into the coordinate system of octant 2 by specifying <code>k=1</code> and <code>f=2</code>. While from the perspective of octree coordinates <code>k=2</code> octant 1 is at <code>xyz=(-2,0)</code>, the returned and transformed octant is located at <code>xyz=(0,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1480-L1502">source</a></section></article><p>Note that we flipped the input and to expected output logic a bit to the proposed algorithms of the paper. However, the original proposed versions are implemented as well in:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_corner_remote" href="#Ferrite.AMR.transform_corner_remote"><code>Ferrite.AMR.transform_corner_remote</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_corner_remote(forest,k,c&#39;,oct,inside::Bool)
transform_corner_remote(forest,v::VertexIndex,oct,inside::Bool)</code></pre><p>Algorithm 12 in <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a> to transform corner into different octree coordinate system. Follows exactly the version of the paper by taking <code>oct</code> and looking from the neighbor octree coordinate system (neighboring to <code>k</code>,<code>v</code>) at <code>oct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1623-L1629">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_edge_remote" href="#Ferrite.AMR.transform_edge_remote"><code>Ferrite.AMR.transform_edge_remote</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_edge_remote(forest,k,e,oct,inside::Bool)
transform_edge_remote(forest,e::Edgeindex,oct,inside::Bool)</code></pre><p>Algorithm 10 in <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a> to transform edge into different octree coordinate system. This function looks at the octant from the octree coordinate system of the neighbor that can be found at (k,e)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1646-L1652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Ferrite.AMR.transform_face_remote" href="#Ferrite.AMR.transform_face_remote"><code>Ferrite.AMR.transform_face_remote</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_face_remote(forest::ForestBWG, k::T1, f::T1, o::OctantBWG{dim,N,T2}) -&gt; OctantBWG{dim,N,T1,T2}
transform_face_remote(forest::ForestBWG, f::FaceIndex, o::OctantBWG{dim,N,T2}) -&gt; OctantBWG{dim,N,T2}</code></pre><p>Interoctree coordinate transformation of an given octant <code>o</code> to the face-neighboring of octree <code>k</code> by virtually pushing <code>o</code>s coordinate system through <code>k</code>s face <code>f</code>. Implements Algorithm 8 of <a href="../../references/#BWG2011">Burstedde *et al.* [11]</a>.</p><pre><code class="nohighlight hljs">x-------x-------x
|       |       |
|   3   |   4   |
|       |       |
x-------x-------x
|       |       |
|   1   *   2   |
|       |       |
x-------x-------x</code></pre><p>Consider 4 octrees with a single leaf each and a maximum refinement level of 1 This function transforms octant 1 into the coordinate system of octant 2 by specifying <code>k=2</code> and <code>f=1</code>. While in the own octree coordinate system octant 1 is at <code>xyz=(0,0)</code>, the returned and transformed octant is located at <code>xyz=(-2,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/cabfafa9b26101daa9170d858eb9a7a94d45c236/src/Adaptivity/BWG.jl#L1419-L1438">source</a></section></article><p>despite being never used in the code base so far.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Thursday 23 May 2024 13:09">Thursday 23 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
