<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adaptive Mesh Refinement · Ferrite.jl</title><meta name="title" content="Adaptive Mesh Refinement · Ferrite.jl"/><meta property="og:title" content="Adaptive Mesh Refinement · Ferrite.jl"/><meta property="twitter:title" content="Adaptive Mesh Refinement · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/amr/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/amr/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/topics/amr/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Tutorials overview</a></li><li><a class="tocitem" href="../../tutorials/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../tutorials/linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../../tutorials/incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../../tutorials/hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../../tutorials/plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../../tutorials/transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../../tutorials/computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../../tutorials/stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../../tutorials/porous_media/">Porous media</a></li><li><a class="tocitem" href="../../tutorials/ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../tutorials/linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../../tutorials/dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Topic guide overview</a></li><li><a class="tocitem" href="../fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../FEValues/">FEValues</a></li><li><a class="tocitem" href="../degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../assembly/">Assembly</a></li><li><a class="tocitem" href="../boundary_conditions/">Initial and Boundary Conditions</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../export/">Export</a></li><li class="is-active"><a class="tocitem" href>Adaptive Mesh Refinement</a><ul class="internal"><li><a class="tocitem" href="#Hanging-Nodes"><span>Hanging Nodes</span></a></li><li><a class="tocitem" href="#Balancing"><span>Balancing</span></a></li><li><a class="tocitem" href="#Error-Estimation"><span>Error Estimation</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Topic guides</a></li><li class="is-active"><a href>Adaptive Mesh Refinement</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adaptive Mesh Refinement</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/topics/amr.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Adaptive-Mesh-Refinement"><a class="docs-heading-anchor" href="#Adaptive-Mesh-Refinement">Adaptive Mesh Refinement</a><a id="Adaptive-Mesh-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Mesh-Refinement" title="Permalink"></a></h1><p>Adaptive mesh refinement (AMR) is a computational technique used in finite element analysis to enhance the accuracy and efficiency of simulations. It involves dynamically adjusting the mesh resolution based on some criteria. By refining the mesh in regions where the solution exhibits features of interest, AMR ensures that computational resources are concentrated where they are most needed, leading to more accurate results without a proportional increase in computational cost. This refinement can be achieved in different fashions by either adjusting the mesh size (h-adaptivity), the polynomial order of the Ansatz functions (p-adaptivity) or the nodal positions (r-adaptivity).</p><p>In Ferrite.jl, adaptivity is achieved through a p4est type of implementation which covers h-adaptivity. This approach is designed to handle unstructured hexahedral (in 3D) and quadrilateral (in 2D) meshes. A further restriction of the p4est type of implementation is isotropic refinement, meaning that elements are subdivided into smaller elements of the same shape.</p><p>In AMR different phenomena and vocabulary emerge which we group into the following aspects</p><ul><li>hanging nodes</li><li>balancing</li><li>error estimation</li></ul><h2 id="Hanging-Nodes"><a class="docs-heading-anchor" href="#Hanging-Nodes">Hanging Nodes</a><a id="Hanging-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Hanging-Nodes" title="Permalink"></a></h2><h3 id="What-Are-Hanging-Nodes?"><a class="docs-heading-anchor" href="#What-Are-Hanging-Nodes?">What Are Hanging Nodes?</a><a id="What-Are-Hanging-Nodes?-1"></a><a class="docs-heading-anchor-permalink" href="#What-Are-Hanging-Nodes?" title="Permalink"></a></h3><p>Hanging nodes occur during the process of mesh refinement. When a mesh is refined, some elements may be subdivided while their neighboring elements are not. This results in nodes that lie on the edges or faces of coarser elements but do not coincide with the existing nodes of those elements. These intermediate nodes are referred to as hanging nodes.</p><p>Consider the following situation:</p><pre><code class="nohighlight hljs">x-----------x-----------x               x-----------x-----------x
|7          |8          |9              |7          |8          |9
|           |           |               |           |           |
|           |           |               |           |           |
|           |           |               |           |           |
|           |           |               |           |           |
|           |           |               |           |           |
|           |           |   refinement  |           |           |
x-----------x-----------x   --------&gt;   x-----x-----x-----------x
|4          |5          |6              |4    |14   |5          |6
|           |           |               |     |     |           |
|           |           |               |     |     |           |
|           |           |               x-----x-----x           |
|           |           |               |11   |12   |13         |
|           |           |               |     |     |           |
|           |           |               |     |     |           |
x-----------x-----------x               x-----x-----x-----------x
 1           2           3               1     10     2           3</code></pre><p>The new introduced nodes 10, 11 and 12 are shared and therefore are not hanging nodes. However, the nodes 14 and 13 are not shared with the neighboring coarser element and therefore hanging.</p><h3 id="Implications-of-Hanging-Nodes"><a class="docs-heading-anchor" href="#Implications-of-Hanging-Nodes">Implications of Hanging Nodes</a><a id="Implications-of-Hanging-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Implications-of-Hanging-Nodes" title="Permalink"></a></h3><p>The presence of hanging nodes poses the challenge of non-conformity: A mesh with hanging nodes is non-conforming because the finite element mesh no longer adheres to the requirement that elements meet only at their nodes or along entire edges or faces. This lack of conformity can lead to difficulties in maintaining the continuity of the solution across the mesh. However we can recover the continuity of the solution by constraining the hanging nodes.</p><h3 id="How-to-Treat-Hanging-Nodes"><a class="docs-heading-anchor" href="#How-to-Treat-Hanging-Nodes">How to Treat Hanging Nodes</a><a id="How-to-Treat-Hanging-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Treat-Hanging-Nodes" title="Permalink"></a></h3><p>To address the issues introduced by hanging nodes, specific strategies and constraints are employed. The degrees of freedom (DoFs) associated with hanging nodes are constrained based on the surrounding coarser mesh elements. For example, in a linear finite element method, the value at a hanging node can be constrained to be the average of the values at the adjacent vertices of the coarser element. As for the example above node 13 could be constrained to <span>$\boldsymbol{u}[13]=0.5\boldsymbol{u}[5]+0.5\boldsymbol{u}[2]$</span>. As soon as higher polynomial degrees are involved, things become more involved. In Ferrite, a conformity constraint can be constructed with the ConstraintHandler when using a DofHandler which has been constructed with a grid passed from <code>Ferrite.creategrid(adaptive_grid::ForestBWG)</code>. This conformity constraint ensures that each hanging node is constrained appropriately.</p><pre><code class="language-julia hljs">ch = ConstraintHandler(dh)
add!(ch, Ferrite.ConformityConstraint(:u))</code></pre><h2 id="Balancing"><a class="docs-heading-anchor" href="#Balancing">Balancing</a><a id="Balancing-1"></a><a class="docs-heading-anchor-permalink" href="#Balancing" title="Permalink"></a></h2><p>Hanging nodes can depend in a nested fashion on other hanging nodes. This case complicates the <code>ConformityConstraint</code> massively and is therefore often prohibited by the act of balancing. Mesh balancing refers to the process of ensuring a smooth and gradual transition in element sizes across the computational mesh. This is especially important in adaptive mesh refinement (AMR), where different regions of the mesh may undergo varying levels of refinement based on the solution&#39;s characteristics. The goal of mesh balancing is to prevent isolated regions of excessive refinement, which can lead to inefficiencies in terms of constructing conformity constraints and numerical instability. A famous balancing approach is the 2:1 balance, where it is ensured that a hanging node only depends on non-hanging nodes. Therefore, exactly one level of non-conformity is allowed. An example of this process is visualized below.</p><pre><code class="nohighlight hljs">x-----------x-----------x               x-----------x-----------x
|           |           |               |     |     |           |
|           |           |               |     |     |           |
|           |           |               |     |     |           |
|           |           |               |-----x-----|           |
|           |           |               |     |     |           |
|           |           |               |     |     |           |
|           |           |   balancing   |     |     |           |
x-----x--x--x-----------x   --------&gt;   x-----x--x--x-----------x
|     |  |  |           |               |     |  |  |     |     |
|     x--x--x           |               |     x--x--x     |     |
|     |  |  |           |               |     |  |  |     |     |
x-----x--x--x           |               x-----x--x--x-----x-----|
|     |     |           |               |     |     |     |     |
|     |     |           |               |     |     |     |     |
|     |     |           |               |     |     |     |     |
x-----x-----x-----------x               x-----x-----x-----------x</code></pre><p>Note that in the example above, the top right element hasn&#39;t been refined. However, in some cases it is advantageous to do so in order to have a smoother transition in element size. Therefore, by default, the adaptive mesh is also refined over this vertex, leading to the following result:</p><pre><code class="nohighlight hljs">x-----------x-----------x               x-----------x-----------x
|           |           |               |     |     |     |     |
|           |           |               |     |     |     |     |
|           |           |               |     |     |     |     |
|           |           |               |-----x-----|-----x-----|
|           |           |               |     |     |     |     |
|           |           |               |     |     |     |     |
|           |           |   balancing   |     |     |     |     |
x-----x--x--x-----------x   --------&gt;   x-----x--x--x-----------x
|     |  |  |           |               |     |  |  |     |     |
|     x--x--x           |               |     x--x--x     |     |
|     |  |  |           |               |     |  |  |     |     |
x-----x--x--x           |               x-----x--x--x-----x-----|
|     |     |           |               |     |     |     |     |
|     |     |           |               |     |     |     |     |
|     |     |           |               |     |     |     |     |
x-----x-----x-----------x               x-----x-----x-----------x</code></pre><p>In Ferrite&#39;s p4est implementation, one can call <code>balanceforest!</code> to balance the adaptive grid.</p><pre><code class="language-julia hljs">Ferrite.balanceforest!(adaptive_grid)</code></pre><h2 id="Error-Estimation"><a class="docs-heading-anchor" href="#Error-Estimation">Error Estimation</a><a id="Error-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Estimation" title="Permalink"></a></h2><p>Error estimation is a critical component of adaptive mesh refinement (AMR) in finite element analysis. The primary objective of error estimation is to identify regions of the computational domain where the numerical solution is less accurate and requires further refinement. Accurate error estimation guides the adaptive refinement process, ensuring that computational resources are concentrated in areas where they will have the most significant impact on improving solution accuracy.</p><p>In practice, error estimators evaluate the local error in the finite element solution by comparing it to an approximation of the true solution. Common techniques include residual-based error estimation, where the residuals of the finite element equations are used to estimate the local error, and recovery-based methods, which involve constructing a higher-order approximation of the solution and assessing the difference between this approximation and the finite element solution. By identifying elements with high estimated errors, these methods provide a targeted approach to mesh refinement, enhancing the overall efficiency and accuracy of the simulation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../export/">« Export</a><a class="docs-footer-nextpage" href="../../reference/">Reference overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Wednesday 22 May 2024 12:07">Wednesday 22 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
