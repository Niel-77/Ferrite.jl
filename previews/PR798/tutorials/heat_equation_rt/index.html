<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heat equation (Mixed, RaviartThomas) · Ferrite.jl</title><meta name="title" content="Heat equation (Mixed, RaviartThomas) · Ferrite.jl"/><meta property="og:title" content="Heat equation (Mixed, RaviartThomas) · Ferrite.jl"/><meta property="twitter:title" content="Heat equation (Mixed, RaviartThomas) · Ferrite.jl"/><meta name="description" content="Documentation for Ferrite.jl."/><meta property="og:description" content="Documentation for Ferrite.jl."/><meta property="twitter:description" content="Documentation for Ferrite.jl."/><meta property="og:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/heat_equation_rt/"/><meta property="twitter:url" content="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/heat_equation_rt/"/><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/heat_equation_rt/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Tutorials overview</a></li><li><a class="tocitem" href="../heat_equation/">Heat equation</a></li><li class="is-active"><a class="tocitem" href>Heat equation (Mixed, RaviartThomas)</a><ul class="internal"><li><a class="tocitem" href="#Strong-form"><span>Strong form</span></a></li><li><a class="tocitem" href="#Weak-form"><span>Weak form</span></a></li><li><a class="tocitem" href="#Commented-Program"><span>Commented Program</span></a></li><li><a class="tocitem" href="#Postprocess-the-total-flux"><span>Postprocess the total flux</span></a></li><li><a class="tocitem" href="#heat_equation-plain-program"><span>Plain program</span></a></li></ul></li><li><a class="tocitem" href="../heat_equation_triangle/">Heat equation (Triangle)</a></li><li><a class="tocitem" href="../linear_elasticity/">Linear elasticity</a></li><li><a class="tocitem" href="../incompressible_elasticity/">Incompressible elasticity</a></li><li><a class="tocitem" href="../hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../plasticity/">Von Mises plasticity</a></li><li><a class="tocitem" href="../transient_heat_equation/">Transient heat equation</a></li><li><a class="tocitem" href="../computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../porous_media/">Porous media</a></li><li><a class="tocitem" href="../ns_vs_diffeq/">Incompressible Navier-Stokes equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../dg_heat_equation/">Discontinuous Galerkin heat equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Topic guide overview</a></li><li><a class="tocitem" href="../../topics/fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../../topics/FEValues/">FEValues</a></li><li><a class="tocitem" href="../../topics/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../topics/assembly/">Assembly</a></li><li><a class="tocitem" href="../../topics/boundary_conditions/">Initial and Boundary Conditions</a></li><li><a class="tocitem" href="../../topics/constraints/">Constraints</a></li><li><a class="tocitem" href="../../topics/grid/">Grid</a></li><li><a class="tocitem" href="../../topics/export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li><li><a class="tocitem" href="../../howto/postprocessing/">Post processing and visualization</a></li><li><a class="tocitem" href="../../howto/threaded_assembly/">Multi-threaded assembly</a></li></ul></li><br><li><a class="tocitem" href="../../gallery/">Code gallery</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Heat equation (Mixed, RaviartThomas)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heat equation (Mixed, RaviartThomas)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate-tutorials/heat_equation_rt.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial-heat-equation-rt"><a class="docs-heading-anchor" href="#tutorial-heat-equation-rt">Heat equation (Mixed, RaviartThomas)</a><a id="tutorial-heat-equation-rt-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-heat-equation-rt" title="Permalink"></a></h1><h2 id="Strong-form"><a class="docs-heading-anchor" href="#Strong-form">Strong form</a><a id="Strong-form-1"></a><a class="docs-heading-anchor-permalink" href="#Strong-form" title="Permalink"></a></h2><p class="math-container">\[\nabla \cdot \boldsymbol{q} = h \in \Omega \\
\boldsymbol{q} = - k\ \nabla u \in \Omega \\
\boldsymbol{q}\cdot \boldsymbol{n} = q_n \in \Gamma_\mathrm{N}\\
u = u_\mathrm{D} \in \Gamma_\mathrm{D}\]</p><h2 id="Weak-form"><a class="docs-heading-anchor" href="#Weak-form">Weak form</a><a id="Weak-form-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-form" title="Permalink"></a></h2><h3 id="Part-1"><a class="docs-heading-anchor" href="#Part-1">Part 1</a><a id="Part-1-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1" title="Permalink"></a></h3><p class="math-container">\[\int_{\Omega} \delta u \nabla \cdot \boldsymbol{q}\ \mathrm{d}\Omega = \int_{\Omega} \delta u\ h\ \mathrm{d}\Omega \\
\int_{\Gamma} \delta u \boldsymbol{n} \cdot \boldsymbol{q}\ \mathrm{d}\Gamma -
\int_{\Omega} \nabla (\delta u) \cdot \boldsymbol{q}\ \mathrm{d}\Omega = \int_{\Omega} \delta u\ h\ \mathrm{d}\Omega \\\]</p><h3 id="Part-2"><a class="docs-heading-anchor" href="#Part-2">Part 2</a><a id="Part-2-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2" title="Permalink"></a></h3><p class="math-container">\[\int_{\Omega} \boldsymbol{\delta q} \cdot \boldsymbol{q}\ \mathrm{d}\Omega = - \int_{\Omega} \boldsymbol{\delta q} \cdot \left[k\ \nabla u\right]\ \mathrm{d}\Omega\]</p><p>where no Green-Gauss theorem is applied.</p><h3 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h3><p>The weak form becomes, find <span>$u\in H^1$</span> and <span>$\boldsymbol{q} \in H\mathrm{(div)}$</span>, such that</p><p class="math-container">\[\begin{align*}
-\int_{\Omega} \nabla (\delta u) \cdot \boldsymbol{q}\ \mathrm{d}\Omega &amp;= \int_{\Omega} \delta u\ h\ \mathrm{d}\Omega -
\int_{\Gamma} \delta u\ q_\mathrm{n}\ \mathrm{d}\Gamma
\quad
\forall\ \delta u \in \delta H^1 \\
\int_{\Omega} \boldsymbol{\delta q} \cdot \boldsymbol{q}\ \mathrm{d}\Omega &amp;= - \int_{\Omega} \boldsymbol{\delta q} \cdot \left[k\ \nabla u\right]\ \mathrm{d}\Omega
 \quad \forall\ \boldsymbol{\delta q} \in \delta H\mathrm{(div)}
\end{align*}\]</p><h2 id="Commented-Program"><a class="docs-heading-anchor" href="#Commented-Program">Commented Program</a><a id="Commented-Program-1"></a><a class="docs-heading-anchor-permalink" href="#Commented-Program" title="Permalink"></a></h2><p>Now we solve the problem in Ferrite. What follows is a program spliced with comments. The full program, without comments, can be found in the next <a href="@ref heat_equation-plain-program">section</a>.</p><p>First we load Ferrite, and some other packages we need</p><pre><code class="language-julia hljs">using Ferrite, SparseArrays</code></pre><p>We start by generating a simple grid with 20x20 quadrilateral elements using <code>generate_grid</code>. The generator defaults to the unit square, so we don&#39;t need to specify the corners of the domain.</p><pre><code class="language-julia hljs">#grid = generate_grid(QuadraticTriangle, (20, 20));
grid = generate_grid(Triangle, (20, 20));</code></pre><h3 id="Trial-and-test-functions"><a class="docs-heading-anchor" href="#Trial-and-test-functions">Trial and test functions</a><a id="Trial-and-test-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Trial-and-test-functions" title="Permalink"></a></h3><p>A <code>CellValues</code> facilitates the process of evaluating values and gradients of test and trial functions (among other things). To define this we need to specify an interpolation space for the shape functions. We use Lagrange functions based on the two-dimensional reference quadrilateral. We also define a quadrature rule based on the same reference element. We combine the interpolation and the quadrature rule to a <code>CellValues</code> object.</p><pre><code class="language-julia hljs">ip_geo = Ferrite.default_interpolation(getcelltype(grid))
ipu = Lagrange{RefTriangle, 1}() # Why does it &quot;explode&quot; for 2nd order ipu?
ipq = RaviartThomas{2,RefTriangle,1}()
qr = QuadratureRule{RefTriangle}(2)
cellvalues = (u=CellValues(qr, ipu, ip_geo), q=CellValues(qr, ipq, ip_geo))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(u = CellValues{Ferrite.FunctionValues{1, Lagrange{RefTriangle, 1, Nothing}, Matrix{Float64}, Matrix{Vec{2, Float64}}, Matrix{Vec{2, Float64}}}, Ferrite.GeometryMapping{1, Lagrange{RefTriangle, 1, Nothing}, Matrix{Float64}, Matrix{Vec{2, Float64}}, Nothing}, QuadratureRule{RefTriangle, Float64, 2}, Vector{Float64}}(Ferrite.FunctionValues{1, Lagrange{RefTriangle, 1, Nothing}, Matrix{Float64}, Matrix{Vec{2, Float64}}, Matrix{Vec{2, Float64}}}(Lagrange{RefTriangle, 1}(), [0.16666666666667 0.16666666666667 0.66666666666667; 0.16666666666667 0.66666666666667 0.16666666666667; 0.6666666666666601 0.16666666666666008 0.16666666666666005], [0.16666666666667 0.16666666666667 0.66666666666667; 0.16666666666667 0.66666666666667 0.16666666666667; 0.6666666666666601 0.16666666666666008 0.16666666666666005], Vec{2, Float64}[[NaN, NaN] [NaN, NaN] [NaN, NaN]; [NaN, NaN] [NaN, NaN] [NaN, NaN]; [NaN, NaN] [NaN, NaN] [NaN, NaN]], Vec{2, Float64}[[1.0, 0.0] [1.0, 0.0] [1.0, 0.0]; [0.0, 1.0] [0.0, 1.0] [0.0, 1.0]; [-1.0, -1.0] [-1.0, -1.0] [-1.0, -1.0]]), Ferrite.GeometryMapping{1, Lagrange{RefTriangle, 1, Nothing}, Matrix{Float64}, Matrix{Vec{2, Float64}}, Nothing}(Lagrange{RefTriangle, 1}(), [0.16666666666667 0.16666666666667 0.66666666666667; 0.16666666666667 0.66666666666667 0.16666666666667; 0.6666666666666601 0.16666666666666008 0.16666666666666005], Vec{2, Float64}[[1.0, 0.0] [1.0, 0.0] [1.0, 0.0]; [0.0, 1.0] [0.0, 1.0] [0.0, 1.0]; [-1.0, -1.0] [-1.0, -1.0] [-1.0, -1.0]], nothing), QuadratureRule{RefTriangle, Float64, 2}([0.166666666666665, 0.166666666666665, 0.166666666666665], Vec{2, Float64}[[0.16666666666667, 0.16666666666667], [0.16666666666667, 0.66666666666667], [0.66666666666667, 0.16666666666667]]), [NaN, NaN, NaN]), q = CellValues{Ferrite.FunctionValues{1, RaviartThomas{2, RefTriangle, 1}, Matrix{Vec{2, Float64}}, Matrix{Tensor{2, 2, Float64, 4}}, Matrix{Tensor{2, 2, Float64, 4}}}, Ferrite.GeometryMapping{2, Lagrange{RefTriangle, 1, Nothing}, Matrix{Float64}, Matrix{Vec{2, Float64}}, Matrix{Tensor{2, 2, Float64, 4}}}, QuadratureRule{RefTriangle, Float64, 2}, Vector{Float64}}(Ferrite.FunctionValues{1, RaviartThomas{2, RefTriangle, 1}, Matrix{Vec{2, Float64}}, Matrix{Tensor{2, 2, Float64, 4}}, Matrix{Tensor{2, 2, Float64, 4}}}(RaviartThomas{2, RefTriangle, 1}(), Vec{2, Float64}[[2.03e-322, 0.0] [1.0e-323, 1.5e-323] [0.001, -0.07801155800782028]; [5.0e-324, 0.0] [2.76236e-318, 1.0e-323] [0.0, 6.90101267391587e-310]; [5.0e-324, 6.90101267391587e-310] [1.0e-323, 0.0] [2.0e-323, 1.0e-323]], Vec{2, Float64}[[0.16666666666667, 0.16666666666667] [0.16666666666667, 0.66666666666667] [0.66666666666667, 0.16666666666667]; [-0.83333333333333, 0.16666666666667] [-0.83333333333333, 0.66666666666667] [-0.33333333333333004, 0.16666666666667]; [0.16666666666667, -0.83333333333333] [0.16666666666667, -0.33333333333333004] [0.66666666666667, -0.83333333333333]], Tensor{2, 2, Float64, 4}[[NaN NaN; NaN NaN] [NaN NaN; NaN NaN] [NaN NaN; NaN NaN]; [NaN NaN; NaN NaN] [NaN NaN; NaN NaN] [NaN NaN; NaN NaN]; [NaN NaN; NaN NaN] [NaN NaN; NaN NaN] [NaN NaN; NaN NaN]], Tensor{2, 2, Float64, 4}[[1.0 0.0; 0.0 1.0] [1.0 0.0; 0.0 1.0] [1.0 0.0; 0.0 1.0]; [1.0 0.0; 0.0 1.0] [1.0 0.0; 0.0 1.0] [1.0 0.0; 0.0 1.0]; [1.0 0.0; 0.0 1.0] [1.0 0.0; 0.0 1.0] [1.0 0.0; 0.0 1.0]]), Ferrite.GeometryMapping{2, Lagrange{RefTriangle, 1, Nothing}, Matrix{Float64}, Matrix{Vec{2, Float64}}, Matrix{Tensor{2, 2, Float64, 4}}}(Lagrange{RefTriangle, 1}(), [0.16666666666667 0.16666666666667 0.66666666666667; 0.16666666666667 0.66666666666667 0.16666666666667; 0.6666666666666601 0.16666666666666008 0.16666666666666005], Vec{2, Float64}[[1.0, 0.0] [1.0, 0.0] [1.0, 0.0]; [0.0, 1.0] [0.0, 1.0] [0.0, 1.0]; [-1.0, -1.0] [-1.0, -1.0] [-1.0, -1.0]], Tensor{2, 2, Float64, 4}[[0.0 0.0; 0.0 0.0] [0.0 0.0; 0.0 0.0] [0.0 0.0; 0.0 0.0]; [0.0 0.0; 0.0 0.0] [0.0 0.0; 0.0 0.0] [0.0 0.0; 0.0 0.0]; [-0.0 -0.0; -0.0 -0.0] [-0.0 -0.0; -0.0 -0.0] [-0.0 -0.0; -0.0 -0.0]]), QuadratureRule{RefTriangle, Float64, 2}([0.166666666666665, 0.166666666666665, 0.166666666666665], Vec{2, Float64}[[0.16666666666667, 0.16666666666667], [0.16666666666667, 0.66666666666667], [0.66666666666667, 0.16666666666667]]), [NaN, NaN, NaN]))</code></pre><h3 id="Degrees-of-freedom"><a class="docs-heading-anchor" href="#Degrees-of-freedom">Degrees of freedom</a><a id="Degrees-of-freedom-1"></a><a class="docs-heading-anchor-permalink" href="#Degrees-of-freedom" title="Permalink"></a></h3><p>Next we need to define a <code>DofHandler</code>, which will take care of numbering and distribution of degrees of freedom for our approximated fields. We create the <code>DofHandler</code> and then add a single scalar field called <code>:u</code> based on our interpolation <code>ip</code> defined above. Lastly we <code>close!</code> the <code>DofHandler</code>, it is now that the dofs are distributed for all the elements.</p><pre><code class="language-julia hljs">dh = DofHandler(grid)
add!(dh, :u, ipu)
add!(dh, :q, ipq)
close!(dh);</code></pre><p>Now that we have distributed all our dofs we can create our tangent matrix, using <code>create_sparsity_pattern</code>. This function returns a sparse matrix with the correct entries stored.</p><pre><code class="language-julia hljs">K = create_sparsity_pattern(dh)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1681×1681 SparseArrays.SparseMatrixCSC{Float64, Int64} with 18721 stored entries:
⎡⠻⣦⡀⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⢤⣌⠻⣦⡹⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠈⠓⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡻⣮⡳⣄⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⠻⣦⎦</code></pre><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>In Ferrite constraints like Dirichlet boundary conditions are handled by a <code>ConstraintHandler</code>.</p><pre><code class="language-julia hljs">ch = ConstraintHandler(dh);</code></pre><p>Next we need to add constraints to <code>ch</code>. For this problem we define homogeneous Dirichlet boundary conditions on the whole boundary, i.e. the <code>union</code> of all the face sets on the boundary.</p><pre><code class="language-julia hljs">∂Ω = union(
    getfaceset(grid, &quot;left&quot;),
    getfaceset(grid, &quot;right&quot;),
    getfaceset(grid, &quot;top&quot;),
    getfaceset(grid, &quot;bottom&quot;),
);</code></pre><p>Now we are set up to define our constraint. We specify which field the condition is for, and our combined face set <code>∂Ω</code>. The last argument is a function of the form <span>$f(\textbf{x})$</span> or <span>$f(\textbf{x}, t)$</span>, where <span>$\textbf{x}$</span> is the spatial coordinate and <span>$t$</span> the current time, and returns the prescribed value. Since the boundary condition in this case do not depend on time we define our function as <span>$f(\textbf{x}) = 0$</span>, i.e. no matter what <span>$\textbf{x}$</span> we return <span>$0$</span>. When we have specified our constraint we <code>add!</code> it to <code>ch</code>.</p><pre><code class="language-julia hljs">dbc = Dirichlet(:u, ∂Ω, (x, t) -&gt; 0)
add!(ch, dbc);</code></pre><p>Finally we also need to <code>close!</code> our constraint handler. When we call <code>close!</code> the dofs corresponding to our constraints are calculated and stored in our <code>ch</code> object.</p><pre><code class="language-julia hljs">close!(ch)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintHandler:
  BCs:
    Field: u, Components: [1]</code></pre><p>Note that if one or more of the constraints are time dependent we would use <a href="../../reference/boundary_conditions/#Ferrite.update!"><code>update!</code></a> to recompute prescribed values in each new timestep.</p><h3 id="Assembling-the-linear-system"><a class="docs-heading-anchor" href="#Assembling-the-linear-system">Assembling the linear system</a><a id="Assembling-the-linear-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-the-linear-system" title="Permalink"></a></h3><p>Now we have all the pieces needed to assemble the linear system, <span>$K u = f$</span>. Assembling of the global system is done by looping over all the elements in order to compute the element contributions <span>$K_e$</span> and <span>$f_e$</span>, which are then assembled to the appropriate place in the global <span>$K$</span> and <span>$f$</span>.</p><h4 id="Element-assembly"><a class="docs-heading-anchor" href="#Element-assembly">Element assembly</a><a id="Element-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Element-assembly" title="Permalink"></a></h4><p>We define the function <code>assemble_element!</code> (see below) which computes the contribution for an element. The function takes pre-allocated <code>ke</code> and <code>fe</code> (they are allocated once and then reused for all elements) so we first need to make sure that they are all zeroes at the start of the function by using <code>fill!</code>. Then we loop over all the quadrature points, and for each quadrature point we loop over all the (local) shape functions. We need the value and gradient of the test function, <code>δu</code> and also the gradient of the trial function <code>u</code>. We get all of these from <code>cellvalues</code>.</p><div class="admonition is-info"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Comparing with the brief finite element introduction in <a href="../../topics/fe_intro/#Introduction-to-FEM">Introduction to FEM</a>, the variables <code>δu</code>, <code>∇δu</code> and <code>∇u</code> are actually <span>$\phi_i(\textbf{x}_q)$</span>, <span>$\nabla \phi_i(\textbf{x}_q)$</span> and <span>$\nabla \phi_j(\textbf{x}_q)$</span>, i.e. the evaluation of the trial and test functions in the quadrature point <span>$\textbf{x}_q$</span>. However, to underline the strong parallel between the weak form and the implementation, this example uses the symbols appearing in the weak form.</p></div></div><pre><code class="language-julia hljs">function assemble_element!(Ke::Matrix, fe::Vector, cv::NamedTuple, dr::NamedTuple)
    cvu = cv[:u]
    cvq = cv[:q]
    dru = dr[:u]
    drq = dr[:q]
    # Loop over quadrature points
    for q_point in 1:getnquadpoints(cvu)
        # Get the quadrature weight
        dΩ = getdetJdV(cvu, q_point)
        # Loop over test shape functions
        for (iu, Iu) in pairs(dru)
            δu  = shape_value(cvu, q_point, iu)
            ∇δu = shape_gradient(cvu, q_point, iu)
            # Add contribution to fe
            fe[Iu] -= δu * dΩ
            # Loop over trial shape functions
            for (jq, Jq) in pairs(drq)
                q = shape_value(cvq, q_point, jq)
                # Add contribution to Ke
                Ke[Iu, Jq] += (∇δu ⋅ q) * dΩ
            end
        end
        for (iq, Iq) in pairs(drq)
            δq = shape_value(cvq, q_point, iq)
            for (ju, Ju) in pairs(dru)
                ∇u = shape_gradient(cvu, q_point, ju)
                Ke[Iq, Ju] += (δq ⋅ ∇u) * dΩ
            end
            for (jq, Jq) in pairs(drq)
                q = shape_value(cvq, q_point, jq)
                Ke[Iq, Jq] += (δq ⋅ q) * dΩ
            end
        end
    end
    return Ke, fe
end</code></pre><h4 id="Global-assembly"><a class="docs-heading-anchor" href="#Global-assembly">Global assembly</a><a id="Global-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Global-assembly" title="Permalink"></a></h4><p>We define the function <code>assemble_global</code> to loop over the elements and do the global assembly. The function takes our <code>cellvalues</code>, the sparse matrix <code>K</code>, and our DofHandler as input arguments and returns the assembled global stiffness matrix, and the assembled global force vector. We start by allocating <code>Ke</code>, <code>fe</code>, and the global force vector <code>f</code>. We also create an assembler by using <code>start_assemble</code>. The assembler lets us assemble into <code>K</code> and <code>f</code> efficiently. We then start the loop over all the elements. In each loop iteration we reinitialize <code>cellvalues</code> (to update derivatives of shape functions etc.), compute the element contribution with <code>assemble_element!</code>, and then assemble into the global <code>K</code> and <code>f</code> with <code>assemble!</code>.</p><div class="admonition is-info"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Comparing again with <a href="../../topics/fe_intro/#Introduction-to-FEM">Introduction to FEM</a>, <code>f</code> and <code>u</code> correspond to <span>$\underline{\hat{f}}$</span> and <span>$\underline{\hat{u}}$</span>, since they represent the discretized versions. However, through the code we use <code>f</code> and <code>u</code> instead to reflect the strong connection between the weak form and the Ferrite implementation.</p></div></div><pre><code class="language-julia hljs">function assemble_global(cellvalues, K::SparseMatrixCSC, dh::DofHandler)
    grid = dh.grid
    # Allocate the element stiffness matrix and element force vector
    dofranges = (u = dof_range(dh, :u), q = dof_range(dh, :q))
    ncelldofs = ndofs_per_cell(dh)
    Ke = zeros(ncelldofs, ncelldofs)
    fe = zeros(ncelldofs)
    # Allocate global force vector f
    f = zeros(ndofs(dh))
    # Create an assembler
    assembler = start_assemble(K, f)
    x = copy(getcoordinates(grid, 1))
    dofs = copy(celldofs(dh, 1))
    # Loop over all cels
    for cellnr in 1:getncells(grid)
        # Reinitialize cellvalues for this cell
        cell = getcells(grid, cellnr)
        getcoordinates!(x, grid, cell)
        celldofs!(dofs, dh, cellnr)
        reinit!(cellvalues[:u], cell, x)
        reinit!(cellvalues[:q], cell, x)
        # Reset to 0
        fill!(Ke, 0)
        fill!(fe, 0)
        # Compute element contribution
        assemble_element!(Ke, fe, cellvalues, dofranges)
        # Assemble Ke and fe into K and f
        assemble!(assembler, dofs, Ke, fe)
    end
    return K, f
end</code></pre><h3 id="Solution-of-the-system"><a class="docs-heading-anchor" href="#Solution-of-the-system">Solution of the system</a><a id="Solution-of-the-system-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-of-the-system" title="Permalink"></a></h3><p>The last step is to solve the system. First we call <code>assemble_global</code> to obtain the global stiffness matrix <code>K</code> and force vector <code>f</code>.</p><pre><code class="language-julia hljs">K, f = assemble_global(cellvalues, K, dh);</code></pre><p>To account for the boundary conditions we use the <code>apply!</code> function. This modifies elements in <code>K</code> and <code>f</code> respectively, such that we can get the correct solution vector <code>u</code> by using <code>\</code>.</p><pre><code class="language-julia hljs">apply!(K, f, ch)
u = K \ f;</code></pre><h3 id="Exporting-to-VTK"><a class="docs-heading-anchor" href="#Exporting-to-VTK">Exporting to VTK</a><a id="Exporting-to-VTK-1"></a><a class="docs-heading-anchor-permalink" href="#Exporting-to-VTK" title="Permalink"></a></h3><p>To visualize the result we export the grid and our field <code>u</code> to a VTK-file, which can be viewed in e.g. <a href="https://www.paraview.org/">ParaView</a>.</p><pre><code class="language-julia hljs">u_nodes = evaluate_at_grid_nodes(dh, u, :u)
∂Ω_cells = zeros(Int, getncells(grid))
for (cellnr, facenr) in ∂Ω
    ∂Ω_cells[cellnr] = 1
end
vtk_grid(&quot;heat_equation_rt&quot;, dh) do vtk
    vtk_point_data(vtk, u_nodes, &quot;u&quot;)
    vtk_cell_data(vtk, ∂Ω_cells, &quot;dO&quot;)
end

@show norm(u_nodes)/length(u_nodes)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.007533130061845076</code></pre><h2 id="Postprocess-the-total-flux"><a class="docs-heading-anchor" href="#Postprocess-the-total-flux">Postprocess the total flux</a><a id="Postprocess-the-total-flux-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocess-the-total-flux" title="Permalink"></a></h2><pre><code class="language-julia hljs">function calculate_flux(dh, dΩ, ip, a)
    grid = dh.grid
    qr = FaceQuadratureRule{RefTriangle}(4)
    ip_geo = Ferrite.default_interpolation(getcelltype(grid))
    fv = FaceValues(qr, ip, ip_geo)

    dofrange = dof_range(dh, :q)
    flux = 0.0
    dofs = celldofs(dh, 1)
    ae = zeros(length(dofs))
    x = getcoordinates(grid, 1)
    for (cellnr, facenr) in dΩ
        getcoordinates!(x, grid, cellnr)
        cell = getcells(grid, cellnr)
        celldofs!(dofs, dh, cellnr)
        map!(i-&gt;a[i], ae, dofs)
        reinit!(fv, cell, x, facenr)
        for q_point in 1:getnquadpoints(fv)
            dΓ = getdetJdV(fv, q_point)
            n = getnormal(fv, q_point)
            q = function_value(fv, q_point, ae, dofrange)
            flux += (q ⋅ n)*dΓ
        end
    end
    return flux
end

function calculate_flux_lag(dh, dΩ, ip, a)
    grid = dh.grid
    qr = FaceQuadratureRule{RefTriangle}(4)
    ip_geo = Ferrite.default_interpolation(getcelltype(grid))
    fv = FaceValues(qr, ip, ip_geo)
    dofrange = dof_range(dh, :u)
    flux = 0.0
    dofs = celldofs(dh, 1)
    ae = zeros(length(dofs))
    x = getcoordinates(grid, 1)
    for (cellnr, facenr) in dΩ
        getcoordinates!(x, grid, cellnr)
        cell = getcells(grid, cellnr)
        celldofs!(dofs, dh, cellnr)
        map!(i-&gt;a[i], ae, dofs)
        reinit!(fv, cell, x, facenr)
        for q_point in 1:getnquadpoints(fv)
            dΓ = getdetJdV(fv, q_point)
            n = getnormal(fv, q_point)
            q = function_gradient(fv, q_point, ae, dofrange)
            flux -= (q ⋅ n)*dΓ
        end
    end
    return flux
end

flux = calculate_flux(dh, ∂Ω, ipq, u)
flux_lag = calculate_flux_lag(dh, ∂Ω, ipu, u)
@show flux, flux_lag


function get_Ke(dh, cellvalues; cellnr=1)
    dofranges = (u = dof_range(dh, :u), q = dof_range(dh, :q))
    ncelldofs = ndofs_per_cell(dh)
    Ke = zeros(ncelldofs, ncelldofs)
    fe = zeros(ncelldofs)
    x = getcoordinates(grid, cellnr)
    cell = getcells(grid, cellnr)
    reinit!(cellvalues[:u], cell, x)
    reinit!(cellvalues[:q], cell, x)

    # Reset to 0
    fill!(Ke, 0)
    fill!(fe, 0)
    # Compute element contribution
    assemble_element!(Ke, fe, cellvalues, dofranges)
    return Ke
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_Ke (generic function with 1 method)</code></pre><h2 id="heat_equation-plain-program"><a class="docs-heading-anchor" href="#heat_equation-plain-program">Plain program</a><a id="heat_equation-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#heat_equation-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../heat_equation.jl"><code>heat_equation.jl</code></a>.</p><pre><code class="language-julia hljs">using Ferrite, SparseArrays

#grid = generate_grid(QuadraticTriangle, (20, 20));
grid = generate_grid(Triangle, (20, 20));

ip_geo = Ferrite.default_interpolation(getcelltype(grid))
ipu = Lagrange{RefTriangle, 1}() # Why does it &quot;explode&quot; for 2nd order ipu?
ipq = RaviartThomas{2,RefTriangle,1}()
qr = QuadratureRule{RefTriangle}(2)
cellvalues = (u=CellValues(qr, ipu, ip_geo), q=CellValues(qr, ipq, ip_geo))

dh = DofHandler(grid)
add!(dh, :u, ipu)
add!(dh, :q, ipq)
close!(dh);

K = create_sparsity_pattern(dh)

ch = ConstraintHandler(dh);

∂Ω = union(
    getfaceset(grid, &quot;left&quot;),
    getfaceset(grid, &quot;right&quot;),
    getfaceset(grid, &quot;top&quot;),
    getfaceset(grid, &quot;bottom&quot;),
);

dbc = Dirichlet(:u, ∂Ω, (x, t) -&gt; 0)
add!(ch, dbc);

close!(ch)

function assemble_element!(Ke::Matrix, fe::Vector, cv::NamedTuple, dr::NamedTuple)
    cvu = cv[:u]
    cvq = cv[:q]
    dru = dr[:u]
    drq = dr[:q]
    # Loop over quadrature points
    for q_point in 1:getnquadpoints(cvu)
        # Get the quadrature weight
        dΩ = getdetJdV(cvu, q_point)
        # Loop over test shape functions
        for (iu, Iu) in pairs(dru)
            δu  = shape_value(cvu, q_point, iu)
            ∇δu = shape_gradient(cvu, q_point, iu)
            # Add contribution to fe
            fe[Iu] -= δu * dΩ
            # Loop over trial shape functions
            for (jq, Jq) in pairs(drq)
                q = shape_value(cvq, q_point, jq)
                # Add contribution to Ke
                Ke[Iu, Jq] += (∇δu ⋅ q) * dΩ
            end
        end
        for (iq, Iq) in pairs(drq)
            δq = shape_value(cvq, q_point, iq)
            for (ju, Ju) in pairs(dru)
                ∇u = shape_gradient(cvu, q_point, ju)
                Ke[Iq, Ju] += (δq ⋅ ∇u) * dΩ
            end
            for (jq, Jq) in pairs(drq)
                q = shape_value(cvq, q_point, jq)
                Ke[Iq, Jq] += (δq ⋅ q) * dΩ
            end
        end
    end
    return Ke, fe
end

function assemble_global(cellvalues, K::SparseMatrixCSC, dh::DofHandler)
    grid = dh.grid
    # Allocate the element stiffness matrix and element force vector
    dofranges = (u = dof_range(dh, :u), q = dof_range(dh, :q))
    ncelldofs = ndofs_per_cell(dh)
    Ke = zeros(ncelldofs, ncelldofs)
    fe = zeros(ncelldofs)
    # Allocate global force vector f
    f = zeros(ndofs(dh))
    # Create an assembler
    assembler = start_assemble(K, f)
    x = copy(getcoordinates(grid, 1))
    dofs = copy(celldofs(dh, 1))
    # Loop over all cels
    for cellnr in 1:getncells(grid)
        # Reinitialize cellvalues for this cell
        cell = getcells(grid, cellnr)
        getcoordinates!(x, grid, cell)
        celldofs!(dofs, dh, cellnr)
        reinit!(cellvalues[:u], cell, x)
        reinit!(cellvalues[:q], cell, x)
        # Reset to 0
        fill!(Ke, 0)
        fill!(fe, 0)
        # Compute element contribution
        assemble_element!(Ke, fe, cellvalues, dofranges)
        # Assemble Ke and fe into K and f
        assemble!(assembler, dofs, Ke, fe)
    end
    return K, f
end

K, f = assemble_global(cellvalues, K, dh);

apply!(K, f, ch)
u = K \ f;

u_nodes = evaluate_at_grid_nodes(dh, u, :u)
∂Ω_cells = zeros(Int, getncells(grid))
for (cellnr, facenr) in ∂Ω
    ∂Ω_cells[cellnr] = 1
end
vtk_grid(&quot;heat_equation_rt&quot;, dh) do vtk
    vtk_point_data(vtk, u_nodes, &quot;u&quot;)
    vtk_cell_data(vtk, ∂Ω_cells, &quot;dO&quot;)
end

@show norm(u_nodes)/length(u_nodes)

function calculate_flux(dh, dΩ, ip, a)
    grid = dh.grid
    qr = FaceQuadratureRule{RefTriangle}(4)
    ip_geo = Ferrite.default_interpolation(getcelltype(grid))
    fv = FaceValues(qr, ip, ip_geo)

    dofrange = dof_range(dh, :q)
    flux = 0.0
    dofs = celldofs(dh, 1)
    ae = zeros(length(dofs))
    x = getcoordinates(grid, 1)
    for (cellnr, facenr) in dΩ
        getcoordinates!(x, grid, cellnr)
        cell = getcells(grid, cellnr)
        celldofs!(dofs, dh, cellnr)
        map!(i-&gt;a[i], ae, dofs)
        reinit!(fv, cell, x, facenr)
        for q_point in 1:getnquadpoints(fv)
            dΓ = getdetJdV(fv, q_point)
            n = getnormal(fv, q_point)
            q = function_value(fv, q_point, ae, dofrange)
            flux += (q ⋅ n)*dΓ
        end
    end
    return flux
end

function calculate_flux_lag(dh, dΩ, ip, a)
    grid = dh.grid
    qr = FaceQuadratureRule{RefTriangle}(4)
    ip_geo = Ferrite.default_interpolation(getcelltype(grid))
    fv = FaceValues(qr, ip, ip_geo)
    dofrange = dof_range(dh, :u)
    flux = 0.0
    dofs = celldofs(dh, 1)
    ae = zeros(length(dofs))
    x = getcoordinates(grid, 1)
    for (cellnr, facenr) in dΩ
        getcoordinates!(x, grid, cellnr)
        cell = getcells(grid, cellnr)
        celldofs!(dofs, dh, cellnr)
        map!(i-&gt;a[i], ae, dofs)
        reinit!(fv, cell, x, facenr)
        for q_point in 1:getnquadpoints(fv)
            dΓ = getdetJdV(fv, q_point)
            n = getnormal(fv, q_point)
            q = function_gradient(fv, q_point, ae, dofrange)
            flux -= (q ⋅ n)*dΓ
        end
    end
    return flux
end

flux = calculate_flux(dh, ∂Ω, ipq, u)
flux_lag = calculate_flux_lag(dh, ∂Ω, ipu, u)
@show flux, flux_lag


function get_Ke(dh, cellvalues; cellnr=1)
    dofranges = (u = dof_range(dh, :u), q = dof_range(dh, :q))
    ncelldofs = ndofs_per_cell(dh)
    Ke = zeros(ncelldofs, ncelldofs)
    fe = zeros(ncelldofs)
    x = getcoordinates(grid, cellnr)
    cell = getcells(grid, cellnr)
    reinit!(cellvalues[:u], cell, x)
    reinit!(cellvalues[:q], cell, x)

    # Reset to 0
    fill!(Ke, 0)
    fill!(fe, 0)
    # Compute element contribution
    assemble_element!(Ke, fe, cellvalues, dofranges)
    return Ke
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../heat_equation/">« Heat equation</a><a class="docs-footer-nextpage" href="../heat_equation_triangle/">Heat equation (Triangle) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Thursday 25 April 2024 15:32">Thursday 25 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
